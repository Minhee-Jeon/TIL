![12865](https://user-images.githubusercontent.com/58028527/80365111-0c52b000-88c2-11ea-9282-458a7dc2ea84.png)    

**배낭 문제(Knapsack Problem)** 는 조합 최적화의 유명한 문제이다.    

배낭에 담을 수 있는 무게의 최댓값이 정해져 있고, 일정 가치와 무게가 있는 짐들을 배낭에 넣을 때, 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제이다.       다.

이 배낭문제는 짐을 쪼갤 수 있는 경우(분할가능 배낭문제)와 짐을 쪼갤 수 없는 경우(배낭문제) 두 가지로 나눌 수 있는데,      
**분할 가능한 경우에는 그리디 알고리즘**으로, **분할할 수 없는 경우에는 동적계획법(Dynamic Programming)** 등으로 풀 수 있다.     

위 문제는 가방에 넣을 수 있는 물건의 무게가 정해져 있고, 각 물건마다 무게와 가치가 입력된다.    
이 때 정해진 무게만큼 물건을 넣을 때 최대 이윤을 출력하는 것이다.    

***

먼저, 구해야 되는 게 무엇인지 생각해보자.    
-> 문제는 정해진 무게만큼 가방에 물건을 넣을 때 최대 이윤을 구하는 것이다.    

물건별 무게와 가치가 아래와 같다고 할 때,    
|물건 종류|무게|가치|
|------|---|---|
|마카롱|3|6|
|비스킷|4|3|
|초콜릿|5|5|      

먼저 마카롱 하나만 있는 경우 가방 크기별로 **마카롱을 넣을 때 최대이윤이 얼마인지** 생각해보자.         
|가방 크기|0|1|2|3|4|5|6|7|8|9|10|11|12|
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|
|마카롱|0|0|0|6|6|6|6|6|6|6|6|6|6|      

다음으로 비스킷과 같이 선택할 경우의 최대이윤이다.    
|가방 크기|0|1|2|3|4|5|6|7|8|9|10|11|12|
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|
|마카롱|0|0|0|6|6|6|6|6|6|6|6|6|6|
|비스킷|0|0|0|6|6|6|6|9|9|9|9|9|9|    

   * 가방의 크기가 4인 경우,     
      - 비스킷을 챙길 경우 남은 공간 0, 마카롱을 챙길 수 없어 가치는 3    
      - 비스킷을 챙기지 않고 마카롱을 챙길 경우의 가치는 6    
   	-> 이 두 가지 경우 중 최대 이윤인 6을 저장    
	    
   * 가방의 크기가 6인 경우    
   	- 비스킷을 챙길 경우 남은 공간 2, 마찬가지로 더 챙길 수 없어 가치는 2    
  	- 비스킷을 챙기지 않을 경우, 가치는 6, 최대 이윤은 6      
	    
   * 가방의 크기가 7인 경우    
  	- 비스킷 챙기면 남은 공간 3, 가방의 크기가 3일 떄 마카롱을 챙길 떄 최대이윤은 이미 6으로 구해두었다. 즉, 3+6 = 9 이윤은 9    
   	- 비스킷 챙기지 않은 경우 6과 9 중 최대 이윤 9가 저장된다.    

마지막으로 초콜릿을 선택할 경우, 위와 같은 방식으로 비교하게 된다.      
|가방 크기|0|1|2|3|4|5|6|7|8|9|10|11|12|
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|
|마카롱|0|0|0|6|6|6|6|6|6|6|6|6|6|
|비스킷|0|0|0|6|6|6|6|9|9|9|9|9|9|
|초콜릿|0|0|0|6|6|6|6|9|9|**11**|11|11|11|    

   - 가방의 크기가 7인 경우,      
   	* 초콜릿을 챙길 경우, 남은 공간 2, 남은 공간이 2일 경우 마카롱, 비스킷 두가지 모두를 이용해도 더 넣을 수가 없으므로 가치는 5,    
   	* 초콜릿을 챙기지 않은 경우 이전에 구해둔 9가 최대이기 때문에 최대이윤은 9     

 

   - 가방의 크기가 8인 경우        
   	* 초콜릿을 챙기면, 남은공간은 3, 이미 테이블을 통해 가방의 크기가 3일 때 마카롱/비스킷을 이용해 구할 수 있는 최대 이윤 6을 구했었다.     

         초콜릿 가치  5 + ~비스킷까지 넣을  최대이윤 6 = 11, 즉 최대이윤이 11이 된다.     



> 우선 점화식은 기본적으로 dp[i][j]의 값은 dp[i-1][j]값이다.     
dp[i-1][j]와 자신의 무게를 뺐을 때 남은 무게로 담을 수 있는 가치를 자신의 가치와 더해 비교해야 한다.    
**dp[i][j] =  dp[i-1][j - w[i]] + v[i]**              
가방 크기가 7일 때 마카롱에서 구한 가치가 6이고, 7에서 마카롱의 무게 3을 뺀 4의 무게가 남는다.   
4의 무게를 더 담을 수 있으므로 비스킷에서 무게가 4일 때 구해놓은 가치와 자신의 가치를 합치면 된다.

```java
import java.util.*;

public class Main {
	static int n,k;
	static int dp[][],w[],v[]; // dp배열과 무게, 가치배열
	
	
	public static void main(String[] args)   {
		Scanner sc = new Scanner(System.in);
		
		n = sc.nextInt();
		k = sc.nextInt();
		
		dp = new int[n+1][k+1];
		
		w =new int[n+1];
		v = new int[n+1];
		
		for(int i=1;i<=n;i++) {			
			w[i] = sc.nextInt();
			v[i]= sc.nextInt();
		
		}
		
		
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=k;j++) {
				dp[i][j] = dp[i-1][j]; // 기본적으로 이전 아이템의 가치를 저장한다.
				if(j - w[i]>=0) { // 무게에서 자신의 무게를 뺐을 때 남는 무게가 존재하면,
					dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]); // 이전 아이템에서 구한 가치와 남은 무게의 가치 + 자신의 가치 중 큰 값을 취한다.
				}
			}
		}
		
		System.out.println(dp[n][k]);
		
		
		
	}
	
}
```
