![트리의지금](https://user-images.githubusercontent.com/58028527/81634375-d11bb980-9449-11ea-8f1b-6b846d3e7fd3.png)
가장 길게 늘어나는 경우인 두 노드를 찾는 것이 문제의 핵심이다.   

쉽게 알 수 있는 것은 두 노드는 가장 아래에 있는 노드가 될 것이다.   

그렇기에, 가장 깊이 있는 노드를 찾아야하기에 DFS가 적합하게 된다.   



가장 깊은 노드 중 가중치가 가장 큰 노드를 찾는다.   

찾은 노드를 기준 정점으로 잡고, 다시 한번 가장 가중치가 큰 노드를 찾는다.   



2번의 DFS를 통해 문제를 해결할 수 있다.   


```java
static int v, u, r;   //자식노드, , 여태까지 가중치 중 
static ArrayList<Node>[] adj; //Node 클래스를 담을 배열
static int[] dist;
 
private void solve() {
    adj = (ArrayList<Node>[]) new ArrayList[10001];
    dist = new int[10001];
 
    for (int i = 1; i <= 10000; i++) {
        adj[i] = new ArrayList<>();
    }
 
    int n = sc.nextInt();
 
    for (int i = 0; i < n - 1; i++) {
        int parent = sc.nextInt();
        int child = sc.nextInt();
        int weight = sc.nextInt();
 
        adj[parent].add(new Node(child, weight));
        adj[child].add(new Node(parent, weight));
    }
 
    dfs(1, 0);
 
    r = 0;
    dist = new int[10001];
 
    dfs(u, 0);  //u: 자식노드
    System.out.println(r);
}
 
public static void dfs(int v, int d) {
    dist[v] = d;
 
    if (dist[v] > r) {
        r = dist[v];
        u = v;
    }
 
    for (Node node : adj[v]) {
        int next = node.v;
        int weight = node.w;
 
        if (dist[next] == 0) {
            dfs(next, d + weight);
        }
    }
 
}
 
public class Node {
    int v;
    int w; //
 
    Node(int v, int w) {
        this.v = v;
        this.w = w;
    }
}

```
