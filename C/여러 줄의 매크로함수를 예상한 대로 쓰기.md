# 여러 줄의 매크로함수를 예상한 대로 쓰기    
```c
#include <stdio.h>
#define AAA(a)\
a*=a; \
a-=1;

int main(void) {
  int k=2;

  if(k%2 == 1) AAA(k);

  printf("k=%d\n",k);
  return 0;
}
```
## 개요   
매크로함수 AAA가   
```c
#define AAA(a) \
a*=a; \
a-=1; 
```
와 같이 정의되어 있을 때 AAA가 전처리되면 a*=a;는 if문으로 걸러지겠지만,
개행된 a-=1;은 꼼짝없이 main함수에 풀어지게 된다.          
때문에 원하던 출력값인 2 대신, -1 된 1이 출력된다.            
이 때 main함수 부분의 코드 수정 없이 선행처리부만 고쳐서 이 매크로함수가 정상 작동되도록 하려고 한다.            
   
## 전개
   
개행을 사용하는 매크로함수도 DB의 트랜잭션처럼 **모두 반영되던가, 아니면 전혀 반영되지 않아야 한다.**         
1. [AAA의 개행을 없애고 한번에 실행하도록 한줄로 축약하기]는 모든 매크로함수에서 통하는 방법이 아니다.              
  한 줄로 축약할 수 없는 경우가 많을 것이기 때문이다.          

2. AAA 안에서 고치는 게 의미가 있을까? 어차피 위의 한 줄이 if문 때문에 똑 잘리게 될텐데.. 전체를 싸주는 중괄호도 아래 닫힘괄호만 남겨질 것 같다.        
  맨 윗줄이 실행되지 않으면 아랫줄 모두 실행되지 않게 하는 한 줄로 끝나는 마법의 문장을 만들 수 있다면..ㅠㅠ       
  근데 전처리를 먼저 하고 코드를 한줄한줄 읽어 나가기 때문에 어차피 앞 한줄이 빠진 매크로함수의 내용으로 바뀌어 있을 것이다.           
  미래에 어떤 경우들이 있을 줄 알고 과거에서 손을 써두는가....?           

3. AAA 위에 [매크로함수의 코드가 한 줄이라도 실행되지 않으면 모든 줄이 실행되지 않게 하는] 다른 매크로함수 BBB를 만든다.     
  - 어떻게 하면 [ ] 기능의 함수가 구현되겠는가?         
  ```c
  #define c     no?:break;
  #define BBB   int no = 0;
  #define AAA(a) BBB;\
  c a*=a; \
  c a-=1;
 ```
   + main함수의 AAA(k); 부분은 앞 한줄이 빠진 AAA함수의 내용으로 바뀌어있을 것이다.         
     BBB의 no의 선언과 초기화식이 날아가버려서 c 자체가 컴파일에러가 남. 선언되지 않은 식별자를 사용하는 매크로함수 c에서 컴파일 에러가 발생한다.         
   그렇다고      
   + BBB의 첫 줄을 의미없는 코드로 쓰고 int no=0;을 나중에 쓰자니 그렇다기엔 변수 no는 항상 0이라 c에서 break; 처리가 되지 않는다.        
   + BBB의 두 번째 줄에 no=0;을 하자니             
      - 첫줄이 생략되었을 때 자료형이 정해지지 않아 컴파일에러가,            
      - 다시 int no=0;을 하자니 위 1.과 동일한 오류에 빠지기도 하고, 첫줄이 생략되지 않았을 때 재정의 때문에 컴파일에러가 발생한다.              
   변수가 존재하는지 확인할 수 있는 방법이 있다면 그걸 c 삼항연산자 조건부에 쓰고 싶다. (검색해보니 javascript에나 있는 듯하다. 엉엉)          

 - 매크로 BBB를 AAA 앞에 정의하고 BBB의 실행 키워드를 AAA의 각 줄에 입력해두면 실행이 되긴 하는가? -> 실행된다. 코드는 위에서 아래로!          
      
4. 애초부터 main함수에서 매크로함수를 쓸 때 조건문/반복문 뒤에 사용 시 중괄호를 쳐주자. (지금은 실행불가)    
    
## 해결   
이렇게 2. 위주로 복잡하게(?) 생각했지만 답은 매우 간단했다^^... 지금 보니 4. 에 가까운 것 같다.
```c
#include <stdio.h>
#define AAA(a) { \
a*=a; \
a-=1; \
}
```
매크로함수 AAA를 전체적으로 중괄호를 씌워 주면 main함수에서는 다음과 같이 치환된다.   
```c
int main(void) {
  int k=2;

  if(k%2 == 1){ \
  a*=a; \
  a-=1; \
  }
  printf("k=%d\n",k);
  return 0;
}
```   
하지만 이 경우에도 문제가 생긴다. main함수를 다음과 같이 바꿔본다면 어떤 일이 생길까?   
```c
int main(void) {
  int a=2;
  int k=1;

  if(a%2 == 1) AAA(a);
  else AAA(k);

  printf("a=%d\n",a);
  printf("k=%d\n",k);  
  return 0;
}
```   
```AAA()```가 치환된다면 이런 모양새가 될 것이다.   
```c
if(a%2 == 1) AAA(a) { \
a*=a; \
a-=1; \
};
else AAA(k) { \
k*=k; \
k-=1; \
};

```    
```if문```이 끝나는 지점에서 ```}``` 뒤에 위치한 ```;``` 때문에 틀린 문법이 되어 또다시 컴파일 에러가 뜬다.   
우리는 함수호출문 뒤에 반드시 ```;```를 붙인다. 그 말은 매크로함수를 정의할 때 중괄호로 싸더라도 그 뒤에 올 ```;```에 대비하여 또 무언가 작업을 해야한다는 것을 의미한다.     
매크로함수에 어떤 작업을 하면 될까?    
우리가 배운 C 문법 중 ```;```가 꼭 붙는 문법으로 ```do{...} while();```문이 있다. 심지어 ```while(0)```으로 조건문을 넣으면 중괄호 부분은 딱 한번만 실행된다.   
```c
#include <stdio.h>
#define AAA(a) do { \
a*=a; \
a-=1; \
} while(0)



int main(void) {
  int a=2;
  int k=1;

  if(a%2 == 1) AAA(a);
  else AAA(k);

  printf("a=%d\n",a);
  printf("k=%d\n",k);  
  return 0;
}
```
이렇게 ```AAA```를 수정하면 main함수의 매크로함수 호출문 뒤에 ```;```를 붙이더라도 문법적 오류 없이 원하는 값을 출력할 수 있다!

