# 07. 연산자
>**연산자**는 하나 이상의 표현식(피연산자)을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.        
        
## 산술 연산자
산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만들고, 산술 연산이 불가능하다면 NaN을 반환한다.       
#### 이항 산술 연산자
- `+` 덧셈     
- `-` 뺄셈        
- `*` 곱셈        
- `/` 나눗셈     
- `%` 나머지        
#### 문자열 연결 연산자
**`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작**한다.      
> 동료 개발자 분이 '나는 이래서 자바스크립트가 싫다'고 보여준 예시.     
처음엔 나도 뜨악했지만 이제 왜 이렇게 동작했는지 알겠다.        
여기서 `+`는 문자열 연결 연산자로, `-`은 이항 산술 연산자로 동작했다.         
![](https://velog.velcdn.com/images/skdixm/post/a6d7f1e9-65b3-407b-82fc-32cdf1b90ca1/image.PNG)     

#### 단항 산술 연산자       
- `++` 증가 & 피연산자의 값을 증가시킨다.       
- `--` 감소 & 피연산자의 값을 감소시킨다.          
```js
var x = 5, result;

// 선할당 후증가 
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당
result = --x;
console.log(result, x); // 5 5
```
- `+` 피연산자를 숫자 타입으로 변환한다.     
- `-` 숫자의 부호를 반대로 반전 & 피연산자를 숫자 타입으로 변환한다.      
      
true => 1, false => 0, null => 0으로 타입 변환되지만 undefined는 숫자로 타입 변환되지 않는다.       

## 할당 연산자
우항에 있는 피연산자의 평가 결과를 좌항의 변수에 할당한다.      
할당문은 값으로 평가되는 표현식인 문이므로 여러 변수에 동일한 값을 연쇄 할당할 수 있다.         
## 비교 연산자
#### 동등/일치 비교 연산자
**동등 비교 연산자(`==`)**는 피연산자를 비교할 때 **타입을 일치**시킨 후(암묵적 타입 변환) **같은 값인지 비교**한다.       
=> 예측하기 어려움 => 사용하지 않는 편이 좋다.      
```js
5 == 5; // true
5 == '5'; // true
5 != '5'; // false
```

**일치 비교 연산자(`===`)**는 피연산자의 **타입도 같고 값도 같은 경우에 한하여  true를 반환**한다.     
=> 예측이 쉽다.        
```js
5 === 5; // true
5 === '5'; // false
5 !== '5'; // true

// 일치 비교 연산자를 사용하지 않는 경우
// 1. NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false
//    따라서 빌트인 함수 Number.isNaN을 사용하자.
Number.isNaN(1 + undefined); // true
Number.isNaN(10); // false

// 2. 자바스크립트의 양의 0과 음의 0을 비교 연산자로 비교 시 true가 반환된다.
0 === -0; // true
0 == -0; // true
//	  Object.is 메서드로 비교하자.
Object.is(-0, +0); // false
Object.is(NaN, NaN); // true
```
#### 대소 비교 연산자
피연산자의 크기를 비교하여 불리언 값을 반환한다.        
`>`, `<`, `>=`, `<=`       
## 삼항 조건 연산자
```js
var result = condition ? trueVal : falseVal;
```
단일 조건에 따라 값을 결정해야 한다면 `if...else`문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다.     
- 표현식이 아닌 문인 `if...else`문과 다르게 삼항 조건 연산자 표현식은 **값으로 평가될 수 있는 표현식인 문**이라 다른 표현식의 일부가 될 수 있어 유용하다.      
- 가독성       
       
하지만 조건이 여러 개라면 `if...else`문의 가독성이 더 좋다.        
## 논리 연산자
피연산자를 논리 연산한다. 단, 암묵적 타입 변환이 일어나기 때문에 피연산자는 반드시 불리언 값일 필요는 없다.      
또 논리합(`||`)이나  논리곱(`&&`) 연산자 표현식은 언제나 2개의 피연산자 중 한 쪽으로 평가되기 때문에 평가 결과는 불리언 값이 아닐 수도 있다.         
```js
// 암묵적 타입 변환
!0;		  // true
!'Hello'; // false

// 단축 평가
'Cat' && 'Dog'; // 'Dog'
```
## 쉼표 연산자
왼쪽부터 차례대로 피연산자를 평가해 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.     
```js
var x, y, z;
x = 1, y = 2, z = 3; // 3
```
## 그룹 연산자
그룹 연산자(`()`)는 연산자 우선순위가 가장 높기 때문에 잘 사용하면 연산자의 우선순위를 조절할 수 있다.       
## typeof 연산자
`typeof` 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.           
         
`typeof null` 연산시 `"object"`가 반환되니 값의 null 여부를 확인할 때에는 일치 연산자를 사용하도록 하자.        
또 선언하지 않은 식별자를 `typeof` 연산해보면 `ReferenceError` 대신 `undefined`를 반환한다.         
```js
var foo = null;

typeof foo === null; // false
foo === null;		 // true

typeof undeclared; // undefined

```
## 지수 연산자
ES7에서 도입되어 `Math.pow()` 메서드를 대체하게 되었다. (가독성 업!)           
지수 연산자(`**`)는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱한다. 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.         
```js
// 지수 연산자의 결합 순서: 우->좌 && 가독성 굿
2 ** ( 3 ** 2 ); // 512
Math.pow(2, Math.pow(3, 2)); // 512

// 좌항에 음수가 위치한다면 괄호로 묶어야 한다.
(-5) ** 2;

// 할당 연산자와 동시 사용이 가능
var num = 5;
num **= 2; // 25

```
## 그 외의 연산자
|연산자|설명|    
|---|---|       
|?.|옵셔널 체이닝 연산자|        
|??|null 병합 연산자|        
|delete|프로퍼티 삭제|       
|new|생성자 함수를 호출할 때 사용해 인스턴스를 생성|        
|instanceof|좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별|         
|in|프로퍼티 존재 확인|       
## 연산자의 부수 효과
일부 연산자는 **다른 코드에 영향**을 주는 **부수 효과**를 가진다.     
- 할당 연산자(`=`): 변수 값이 변하며, 해당 변수를 사용하는 다른 코드에 영향을 준다.      
- 증가/감소 연산자(`++`/`--`): 피연산자의 값이 재할당되어 변경되며, 해당 변수를 사용하는 다른 코드에 영향을 준다.      
- `delete` 연산자는 객체의 프로퍼티를 삭제하며, 이는 해당 객체를 사용하는 다른 코드에 영향을 준다.      
## 연산자 우선순위
연산자의 종류가 많아 우선순위를 기억하기보다는 우선순위가 가장 높은 **그룹 연산자(`()`)를 이용해 명시적으로 우선순위를 조절**하자.        
## 연산자 결합 순서
|결합 순서|연산자|        
|---|---|         
|좌항->우항|+  -  /  %  <  <=  >  >=  &&  \|\|  .  []  ??  ?.  in instanceof|       
|우항->좌항|++ -- 할당연산자(= += -+, ...) !x +x -x ++x --x typeof delete ? **|         
