# 11. 원시 값과 객체의 비교
자바스크립트의 데이터 타입에는 크게 **원시 타입**과 **객체 타입**이 있다.      
그리고 이 두 타입은 다음 세 가지 측면에서 근본적으로 다르다.     
- **원시 값은 변경 불가능한 값**인 반면, **객체(참조) 타입인 객체는 변경 가능한 값**이다.     
- 원시 값이 할당된 변수(확보된 메모리 공간)에는 **실제 값**이 저장되는 데에 비해 객체를 변수에 할당한 변수(확보된 메모리 공간)에는 **참조 값**이 저장된다.     
- 원시 값을 갖는 변수를 다른 변수에 할당하면 **원시 값이 복사되어 전달**된다. (`값에 의한 전달`)     
객체를 가리키는 변수를 다른 변수에 할당하면 **참조 값이 복사되어 전달**된다. (`참조에 의한 전달`)     
## 원시 값
#### 변경 불가능한 값
**변경 불가능하다**는 것은 ~~변수~~가 아니라 **값**에 대한 진술이며, 변수는 언제든 재할당으로 변수 값을 교체할 수 있다.     
상수는 할당이 단 한번만 가능해 변수 값을 변경할 수 없다.     
     
자바스크립트에서 원시 값을 변수에 재할당하면 변수는 새로운 메모리 공간을 확보해 재할당한 원시 값을 저장하고 변수는 새롭게 재할당한 원시 값을 가리킨다.     
**불변성을 갖는 원시 값을 할당한 변수는 재할당 외에는 변수 값을 변경할 수 없다.**     
![](https://velog.velcdn.com/images/skdixm/post/81b13a74-312e-47c5-bf72-13f477ee70c2/image.png)     

cf. 내가 사용하던 C++에서는 원시 값이 변경 가능하며, 변수는 선언에서 쓰인 데이터 타입의 크기의 메모리 공간을 확보해 둔다. 재할당 시 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값을 변경한다.     
![](https://velog.velcdn.com/images/skdixm/post/88932750-0750-496e-a003-c9dd6c84450d/image.png)     
     
#### 문자열과 불변성
문자열은 0개 이상의 문자로 이뤄진 집합을 말하며, 문자 하나는 2바이트의 메모리 공간에 저장된다. 따라서 문자열은 몇 개의 문자로 이뤄졌는지에 따라 필요한 메모리 공간의 크기가 결정된다.     
     
```js
var str = 'Hello';
str = 'world';
// 문자열 'Hello'와 'world'는 모두 메모리에 존재한다.
// 식별자 str는 'Hello'를 가리키다가 'world'를 가리키도록 변경되었을 뿐..
```

문자열은 유사 배열 객체(인덱스로 프로퍼티 값에 접근 & length 프로퍼티가 있음)면서도 이터러블이므로 배열과 유사하게 각 문자에 접근 가능하다.     
```js
var str = 'string';

// 인덱스로 문자에 접근은 가능하나 원시 값인 문자열은 변경할 수 없다. 에러는 발생하지 않는다.
str[0] = 'S';
console.log(str); // string
```

이처럼 한번 생성된 문자열은 읽기 전용 값이며 변경할 수 없다.      
=> 예기치 못한 변경에서 자유롭다.     
=> 데이터의 신뢰성이 보장된다.     
     
#### 값에 의한 전달
> 값에 의한 전달이란, 변수에 **원시 값**을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달되는 것을 말한다.     
     
이 때 두 변수는 같은 원시 값을 가지지만, **각 변수의 값은 각각 다른 메모리 공간에 저장된 별개의 값이다.** 식별자는 ~~값~~이 아닌 메모리를 기억하기 때문에 변수에는 ~~값~~이 전달되는 것이 아니라 **메모리 주소**가 전달되기 때문이다.     
     
때문에 어느 한쪽에서 재할당을 통해 값을 변경하더라도 **서로 간섭할 수 없다**.     
```js
var score = 80;

var copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;
console.log(score, copy) // 100 80
console.log(score === copy); //false
```

## 객체
객체는 프로퍼티가 동적으로 추가되고 삭제될 수 있으며, 개수와 값이 정해져 있지 않다.     
=> 확보할 메모리 공간의 크기를 사전에 정해둘 수가 없다.     
     
객체는 원시 값과 다른 방법으로 동작하도록 설계되었다.     
객체 크기가 매우 크다면 복사해서 생성하는 비용이 많이 들 수 있기 때문에 그 비용을 절약해 **성능을 향상**시키거나 **메모리를 효율적으로 사용**하기 위해 다음과 같이 동작한다.     
     
객체를 할당한 변수에는 **참조 값**(생성된 객체가 저장된 메모리 공간의 주소)이 할당된다.     
= 객체가 할당된 변수는 객체에 대한 포인터로 이해하면 될듯     
     
#### 변경 가능한 값
     
객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정 가능하며, 재할당을 하지 않는다면 참조 값은 변경되지 않는다.     
객체를 할당한 변수는 **재할당 없이** 프로퍼티를 **동적으로 추가**할 수 있고 프로퍼티 값을 **갱신**할 수도 있으며 프로퍼티를 **삭제**할 수도 있다.     
     
객체는 포인터처럼 구조가 설계돼 **여러 식별자가 하나의 객체를 공유할 수 있다**는 **부작용**을 가진다.     
#### 참조에 의한 전달
>객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달**된다.     
= 두 식별자가 **하나의 객체를 공유**하며 서로 영향을 주고받는다.     
     
```js
var person = {
  name: 'Minhee'
};

// 얕은 복사. copy와 person에 담긴 참조값은 동일
var copy = person;

copy.name = 'skdixm';
person.job = 'developer';

// copy와 person이 가리키는 객체는 동일하기 때문에
// 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
console.log(person); // {name:"skdixm", job:"developer"}
console.log(copy); // {name:"skdixm", job:"developer"}
```

```js
var person1 = {
  name: 'Minhee'
};

var person2 = {
  name: 'Minhee'
};

// 객체 리터럴은 평가될 때마다 객체를 생성하기 때문에 두 변수의 참조 값은 전혀 다른 값이다.
console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true

```
