# 12. 함수
## 함수란?
> **함수**는 **입력**을 받아 **출력**을 내보내는 일련의 과정을 **문으로 구현**하고 **코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**이다.        
        
```js
// 함수 정의
function add(x, y) {
  return x + y;
}
// 함수 호출
add(2, 5);
```
- 매개변수: 함수 내부로 입력을 전달받는 변수 _x, y_        
- 인수: 입력 _2, 5_        
        
함수는 **함수 정의**를 통해 생성하고 **함수 호출**을 해 함수의 코드 블록 안의 문들이 일괄적으로 실행 후 반환값을 반환한다.        
## 함수를 사용하는 이유
동일한 작업을 반복 수행할 때 ~~코드의 중복~~ 대신 미리 정의한 함수를 재사용함으로써 **코드의 재사용** 측면에서 유용하다.        
코드 중복 시 중복된 횟수만큼 코드를 수정하는 데에 드는 시간이 증가하나 코드를 재사용한다면 **유지보수의 편의성**과 **코드의 신뢰성**을 높인다.        
또 함수는 객체 타입이기 때문에 식별자를 붙일 수 있으며, 잘 지은 함수명은 **코드의 가독성**을 향상시킨다.        
## 함수 리터럴        
자바스크립트에서 함수는 **객체 타입**이기 때문에 함수도 함수 리터럴로 생성할 수 있다.        
또 **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.**        
```js
// 변수에 함수 리터럴을 할당
var f = function add(x,y) {
  return x + y;
};
```
함수 리터럴의 구성 요소        
- 함수 이름        
    - 식별자이므로 식별자 네이밍 규칙을 준수해야 함        
    - 함수 몸체 내에서만 참조할 수 있는 식별자이다.        
    - 생략 가능하며, 이름이 있는 함수를 _기명 함수_, 이름이 없는 함수를 _무명/익명 함수_라고 한다.        
- 매개변수 목록        
    - 함수 몸체 내에서 변수와 동일하게 취급하므로 식별자 네이밍 규칙을 준수해야 한다.        
- 함수 몸체        
    - 함수 호출 시 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록        
## 함수 정의        
> **함수 정의**란 함수를 호출하기 전에 매개변수와 실행할 문들, 반환할 값을 지정하는 것이다.        
        
정의된 함수는 자바스크립트 엔진이 평가해 함수 객체가 되며 함수를 정의하는 방법에는 네 가지가 있다.        
#### 함수 선언문        
함수 리터럴과 형태가 동일하나 **함수 선언문에서는 함수 이름을 생략할 수 없다.**        
```js
function add (x, y) {
  return x + y;
}

// SyntaxError: Function statements require a function name
function (x, y) {
  return x + y;
}
```
또 함수 선언문은 ~~표현식~~이 아닌 **문**이다. => 변수에 할당할 수 없다.        
        
기명 함수 리터럴에서 `{}`은 중의적 표현이기 때문에 코드의 문맥에 따라 자바스크립트 엔진의 해석이 달라진다.        
- 기명 함수 리터럴이 단독으로 사용되면 => 함수 선언문        
- 함수 리터럴이 값으로 평가되어야 하는 문맥이면 => 함수 리터럴 표현식        
        
```js
// 기명 함수 리터럴 단독 사용 => 함수 선언문 (이름 생략 불가)
function foo() { console.log('foo'); }
foo(); // foo

// 그룹 연산자 () 내에 있는 함수 리터럴
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```

함수 리터럴에서 '함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자'이기 때문에 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다.        
식별자 `foo`를 선언한 적도 할당한 적도 없지만 ** 자바스크립트 엔진이 생성된 함수를 호출하기 위해 함수명과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당**했기에 `foo`가 호출되었다.        
        
이 과정의 의사 코드는 다음과 같다.        
```js
var foo = function foo () {
  console.log('foo');
};

foo();
```
        
**함수는 함수명으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.**        
위 의사 코드는 함수 표현식과 같으므로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 볼 수 있다. (단, 정확히 똑같이 동작 X)        
#### 함수 표현식        
자바스크립트의 **함수**는 값의 성질을 갖는 **일급 객체**이다.        
- 변수에 할당 가능        
- 프로퍼티 값이 될 수 있음        
- 배열의 요소가 될 수 있음        
        
**함수 표현식**은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식을 말한다.        
```js
// 함수 리터럴의 함수명을 생략한 익명 함수로 쓰는 것이 일반적
// var add = function (x, y) {
var add = function foo (x, y) {
  return x + y;  
}

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// ReferenceError: foo is not defined
// 함수 이름은 함수 몸체 내부에서만 유효
console.log(foo(2, 5));
```
##### 함수 생성 시점과 함수 호이스팅
```js
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```
함수 선언문으로 정의한 함수 `add`와 함수 표현식으로 정의한 함수 `sub`의 생성시점이 다르다.        
- 함수 선언문        
  - 런타임 이전에 함수 객체가 먼저 생성 =>        
  - 자바스크립트 엔진이 함수명과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당 =>        
  - 함수가 호이스팅됨        
- 함수 표현식        
  - 변수 호이스팅으로 undefined로 할당되어 있음.        
런타임에 변수 할당문이 평가되어 함수 객체가 된다.        
#### Function 생성자 함수        
```js
var add = new Function ('x', 'y', 'return x + y');
```
Function 생성자 함수로 함수를 생성하면 _클로저를 생성하지 않는 등_ 함수  선언문/함수 표현식으로 생성한 함수와 다르게 동작하므로 **일반적이지 않고 바람직하지 않다.**        
#### 화살표 함수 (ES6)        
```js        
var add = (x, y) => x + y;
```
화살표 함수는 표현도 내부동작도 간략화했다.        
- 생성자 함수로 사용 불가        
- 기존 함수와 다른 this 바인딩 방식        
- prototype 프로퍼티 없음        
- arguments 객체를 생성하지 않음        
## 함수 호출
#### 매개변수와 인수
- 함수는 매개변수의 개수와 인수의 개수가 일치하는 지 체크하지 않는다.        
- 매개 변수보다 인수가 많은 경우 초과된 인수는 무시된다.        
#### 인수 확인
자바스크립트 함수는 매개변수와 인수의 개수가 일치하는 지 확인하지 않고, 동적 타입 언어여서 인수확인이 어렵기 때문에 함수 내부에서 확인을 하거나 기본값을 할당하여 확인해야 한다.        
        
#### 매개변수의 최대 개수        
매개변수는 최대 3개이상 넘지 않는 것을 권장 => 함수는 한 가지 일만 해야하며 가급적 작게 만들어야한다.        
        
#### 반환문
함수 호출은 표현식이다 => return 키워드가 반환한 표현식의 평가 결과값으로 평가되기 때문에        
## 참조에 의한 전달과 외부 상태의 변경
객체 타입인수는 '참조 값'이 복사되어 매개변수에 전달되기 때문에 원본이 변경되지만 원시타입은 값 자체가 복사되어 매개변수에 전달되어서 새로운 메모리에 그 값을 할당하여 사용하기 때문에 부수효과 발생 X        
## 다양한 함수의 형태        
#### 즉시 실행 함수        
함수 정의와 동시에 즉시 호출되는 함수 => 즉시 실행 함수라고 하고 단 한 번만 호출한다.        
```js
// 익명 즉시 실행 함수
(function() {
  var a = 3;
  var b = 5;
  return a * b;
}());

var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(res); // 15

res = (function (a, b) {
  return a * b;
}(3, 5));

console.log(res); // 15
```
그룹 연산자 내의 기명함수는 함수 리터럴로 평가된다. => 함수 이름은 함수 몸체에서만 참조할 수 있으므로 즉시 실행 함수를 다시 호출할 수 없음        
        
즉시 실행 함수는 그룹 연산자로 감싸지 않는다면 SyntaxError가 발생한다.        
        
그룹 연산자의 피연산자는 값으로 평가되는데 기명 또는 무명함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.        
#### 재귀 함수        
함수 자기 자신을 호출하는 것을 재귀 호출이라 하며 재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.        
        
재귀함수는 자신을 무한 호출하기 때문에 탈출 조건을 반드시 만들어야 한다. => 그렇지 않으면 스택 오버플로가 발생        
#### 중첩 함수
함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 한다. 중첩 함수를 포함하는 함수를 외부 함수라고 한다.        
```js
function outer() {
  var x = 1;
  
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수 변수를 참조 가능
    console.log(x + y); // 3
  }
  
  inner();
}

outer();
```
#### 콜백 함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 함. 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수라고 한다.        
        
고차 함수는 콜백 함수를 자신의 일부분으로 합성하고 고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.        
        
콜백함수는 고차 함수에 의해 호출되며, 이때 고차함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.        
#### 순수 함수와 비순수 함수
- 순수함수: 부수 효과가 없는 함수        
- 비순수함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수        
        
함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화 해서 불변성을 지향하는 프로그래밍 패러다임이다.        
함수형 프로그래밍은 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이다.         
자바스크립트는 멀티패러다임 언어로 **객체지향 프로그래밍** 뿐만아니라 **함수형 프로그래밍**을 적극적으로 활용한다.        
